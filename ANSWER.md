### Задание 1
Пусть на вход дан сигнал x[n], а на выход нужно дать два сигнала y1[n] и y2[n]:

```
 y1[n] = x[n - 1] + x[n] + x[n + 1]
 y2[n] = y2[n - 2] + y2[n - 1] + x[n]
```


### Ответ
>Какой из двух сигналов будет проще и быстрее реализовать в модели массового параллелизма на GPU и почему?

Для y1 будет проще и быстрее реализовать в модели массового параллелизма, поскольку при вычсислении
не используются предыдущие значения этого же сигнала.

### Задание 2
Предположим что размер warp/wavefront равен 32 и рабочая группа делится
на warp/wavefront-ы таким образом что внутри warp/wavefront
номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Напоминание: инструкция исполняется (пусть и отмаскированно) в каждом потоке warp/wavefront если хотя бы один поток выполняет эту инструкцию неотмаскированно. Если не все потоки выполняют эту инструкцию неотмаскированно - происходит т.н. code divergence.

Пусть размер рабочей группы (32, 32, 1)

```
int idx = get_local_id(1) + get_local_size(1) * get_local_id(0);
if (idx % 32 < 16)
    foo();
else
    bar();
```

### Ответ
> Произойдет ли code divergence? Почему?

Нет, не произойдет. **get_local_id(0)** Возвращает значение по x, а get_local_id(1) - по y.
При этом x меняется чаще, чем y. Тогда в потоках значения idx будут одинаковы по модулю 32. Например, 0, 32, 64, ... .
Отсюда следует, что все потоки будут всегда заходить в одну ветку if-а.

### Задание 3
Как и в прошлом задании предположим что размер warp/wavefront равен 32 и рабочая группа делится
на warp/wavefront-ы таким образом что внутри warp/wavefront
номер WorkItem по оси x меняется чаще всего, затем по оси y и затем по оси z.

Пусть размер рабочей группы (32, 32, 1).
Пусть data - указатель на массив float-данных в глобальной видеопамяти идеально выравненный (выравнен по 128 байтам, т.е. data % 128 == 0). И пусть размер кеш линии - 128 байт.
### Ответ (а)
> **a)**
>```
>data[get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
>```
> Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

Да, поскольку потоки будут обращаться к соседним ячейкам памяти, причем 128 / 4 (float size) = 32, т.е. все доступные потоки
смогут использовать загруженные данные.
Количество кеш линий: 32 раза загрузить кеш линию = 32 кеш линий

### Ответ (b)
> **b)**
>```
>data[get_local_id(1) + get_local_size(1) * get_local_id(0)] = 1.0f;
>```
> Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

Нет, поскольку для работы одного потока нужно будет загрузить одну кеш линию, причем совместных данных для других потоков не будет. 
Количество кеш линий: 32 * 32 = 1024


### Ответ (с)
> **b)**
>```
>data[1 + get_local_id(0) + get_local_size(0) * get_local_id(1)] = 1.0f;
>```
> Будет ли данное обращение к памяти coalesced? Сколько кеш линий записей произойдет в одной рабочей группе?

Да, однако поскольку при обращении к данным существует сдвиг, то для того, чтобы все потоки выполнили работу необходимо загрузить 2 кеш-линии.
Количество кеш линий: 32 * 2 = 64
